The patch below solves the 2.6.25 uml crash problem for me. Looks like the
problem should be away in 2.6.26 kernel because down_interruptible has
changed to the C code since 2.6.26. But I got kernel panic while booting
the 2.6.26 kernel :(.

Index: linux-source-2.6.25/lib/semaphore-sleepers.c
===================================================================
--- linux-source-2.6.25.orig/lib/semaphore-sleepers.c	2008-04-17 11:49:44.000000000 +0900
+++ linux-source-2.6.25/lib/semaphore-sleepers.c	2008-07-19 14:54:18.275652685 +0900
@@ -48,12 +48,12 @@
  *    we cannot lose wakeup events.
  */
 
-void __up(struct semaphore *sem)
+asmregparm void __up(struct semaphore *sem)
 {
 	wake_up(&sem->wait);
 }
 
-void __sched __down(struct semaphore *sem)
+asmregparm void __sched __down(struct semaphore *sem)
 {
 	struct task_struct *tsk = current;
 	DECLARE_WAITQUEUE(wait, tsk);
@@ -90,7 +90,7 @@ void __sched __down(struct semaphore *se
 	tsk->state = TASK_RUNNING;
 }
 
-int __sched __down_interruptible(struct semaphore *sem)
+asmregparm int __sched __down_interruptible(struct semaphore *sem)
 {
 	int retval = 0;
 	struct task_struct *tsk = current;
@@ -153,7 +153,7 @@ int __sched __down_interruptible(struct 
  * single "cmpxchg" without failure cases,
  * but then it wouldn't work on a 386.
  */
-int __down_trylock(struct semaphore *sem)
+asmregparm int __down_trylock(struct semaphore *sem)
 {
 	int sleepers;
 	unsigned long flags;
